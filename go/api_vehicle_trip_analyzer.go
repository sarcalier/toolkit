/*
 * Mercedes-Benz AG Programming Challenge
 *
 * - Implement the specified REST Endpoint - Protect the API with BasicAuth - Use Docker to run your application - Use one of the following languages&#58; Go, Java, Python, C++ - Automate the infrastructure rollout - Use an external service to determine the city name for depature and destination - Upload your solution to a private GitHub repository - Provide a link to the secured hosted instance of your solution - Provide the following files together with your code&#58;   * Dockerfile   * Build-Script   * Deployment-Script   * Kubernetes deployment YAML (if Kubernetes is used)   * Infrastructure automation scripts   * README.md with documentation how to deploy the infrastructure and the application
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"sort"
)

type test_struct struct {
	TestStr string
}

func Analyze(rw http.ResponseWriter, req *http.Request) {
	rw.Header().Set("Content-Type", "application/json; charset=UTF-8")
	rw.WriteHeader(http.StatusOK)
	//fmt.Fprintf(rw, "POST OK")

	/*
		var p VehiclePush
		err := json.NewDecoder(r.Body).Decode(&p)
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
	*/

	decoder := json.NewDecoder(req.Body)
	var t VehiclePush
	err := decoder.Decode(&t)
	if err != nil {
		panic(err)
	}
	log.Println(t.Vin)
	log.Println(t.Data)

	// Do something with the Person struct...
	//fmt.Fprintf(rw, "Push: %+v", t)

	//sorting by odometer to catch the break
	sort.Slice(t.Data, func(i, j int) bool {
		//if t.Data[i].Timestamp < t.Data[j].Timestamp {
		//	return true
		//}
		return t.Data[i].Odometer <= t.Data[j].Odometer
	})

	//log.Println(t.Data)
	log.Println(len(t.Data))

	var b ModelBreak
	//log.Println(b)

	var TripCalc VehiclePushAnalysis
	var LastBreakStartID int

	//collecting breaks
	for i, s := range t.Data {

		//checking if this guy is the last one
		if i == (len(t.Data) - 1) {
			fmt.Println(i, s)

			// closing the last stop
			//b.StartTimestamp = t.Data[LastBreakStartID].Timestamp
			b = ModelBreak{StartTimestamp: t.Data[LastBreakStartID].Timestamp, EndTimestamp: s.Timestamp, PositionLat: s.PositionLat, PositionLong: s.PositionLong}
			TripCalc.Breaks = append(TripCalc.Breaks, b)
			if (b.EndTimestamp - b.StartTimestamp) < int64(t.BreakThreshold) {
				TripCalc.RefuelStops = append(TripCalc.RefuelStops, b)
			}
			TripCalc.Destination = (fmt.Sprintf("%f", s.PositionLat) + "," + fmt.Sprintf("%f", s.PositionLong))
			continue
		}

		//comparing the odo value to get the "break range"
		fmt.Println(i, s)

		//detecting the break range
		if s.Odometer == t.Data[i+1].Odometer {
			//fmt.Println("true")
			//b := ModelBreak{s.Timestamp, s.Timestamp, s.PositionLat, s.PositionLong}
			//fmt.Println(b)

			//catching the break start
			if b.StartTimestamp == 0 {
				LastBreakStartID = i
				b = ModelBreak{StartTimestamp: s.Timestamp}
				//fmt.Println(b.StartTimestamp)
				//fmt.Println("caught")
			}
			//the last point of the brake range
		} else {
			if b.StartTimestamp != 0 {
				b = ModelBreak{StartTimestamp: b.StartTimestamp, EndTimestamp: s.Timestamp, PositionLat: s.PositionLat, PositionLong: s.PositionLong}

				//Writing the breaks and refuels
				TripCalc.Breaks = append(TripCalc.Breaks, b)
				if (b.EndTimestamp - b.StartTimestamp) < int64(t.BreakThreshold) {
					TripCalc.RefuelStops = append(TripCalc.RefuelStops, b)
				}

				//saving the location data
				if TripCalc.Departure == "" {
					TripCalc.Departure = (fmt.Sprintf("%f", s.PositionLat) + "," + fmt.Sprintf("%f", s.PositionLong))
				}
				TripCalc.Destination = (fmt.Sprintf("%f", s.PositionLat) + "," + fmt.Sprintf("%f", s.PositionLong))

				//nilling the break
				b = ModelBreak{}
			}
		}
	}

	//Finishing up the 200 output
	TripCalc.Vin = t.Vin

	//calculating the fuel consumption
	TripCalc.Consumption = 7

	//final output
	fmt.Println(TripCalc)
	json.NewEncoder(rw).Encode(TripCalc)

}
